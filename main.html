<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional 3D Evanolott - Scroll Zoom & Overlay</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Scheherazade New', serif;
            cursor: none;
        }
        
        canvas {
            display: block;
            cursor: none;
        }
        
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #ffffff;
            font-size: 14px;
            font-family: 'Scheherazade New', serif;
            z-index: 100;
            opacity: 0.8;
            background: rgba(0,0,0,0.4);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s ease;
        }
        
        #fps {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #ffffff;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            opacity: 0.7;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 4px;
            transition: opacity 0.3s ease;
        }
        
        /* Semi-transparent overlay */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(8px);
        }
        
        #overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* Motto text styling */
        .motto-text {
            color: #ffffff;
            font-family: 'Scheherazade New', serif;
            text-align: center;
            line-height: 1.6;
            margin: 8px 0;
            transform: translateY(30px);
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .motto-line-1 {
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: 2px;
            text-shadow: 0 4px 20px rgba(255, 255, 255, 0.3);
            transition-delay: 0.2s;
        }
        
        .motto-line-2 {
            font-size: 1.8rem;
            font-weight: 400;
            opacity: 0.9;
            letter-spacing: 1px;
            margin-top: 20px;
            transition-delay: 0.4s;
        }
        
        .motto-line-3 {
            font-size: 1.4rem;
            font-weight: 400;
            opacity: 0.8;
            font-style: italic;
            margin-top: 15px;
            transition-delay: 0.6s;
        }
        
        #overlay.active .motto-text {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Simple timed tutorial hint */
        #timed-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            text-align: center;
            z-index: 102;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
            pointer-events: none;
            font-family: 'Scheherazade New', serif;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        #timed-hint.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .motto-line-1 {
                font-size: 2.2rem;
                letter-spacing: 1px;
            }
            
            .motto-line-2 {
                font-size: 1.5rem;
            }
            
            .motto-line-3 {
                font-size: 1.2rem;
            }
            
            #info, #fps {
                font-size: 12px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        üéØ <strong>Professional 3D Text Lens</strong><br>
        üìç Move cursor to rotate text + explore lens<br>
        üîÑ Scroll up/in to zoom & reveal motto<br>
        üîÆ Outside: Silver metallic "Evanolott"<br>
        üíó Inside lens: Pink gradient + white wireframe<br>
        üíé Professional lighting & performance
    </div>
    
    <div id="fps">FPS: --</div>
    
    <div id="overlay">
        <div class="motto-text motto-line-1">EXCELLENCE IS A JOURNEY</div>
        <div class="motto-text motto-line-2">Not a Destination</div>
        <div class="motto-text motto-line-3">‚Äî Embrace the process, master the craft</div>
    </div>
    
    <div id="timed-hint">
        scroll up/zoom in
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ScrollZoom3DTextRenderer {
            constructor() {
                // Core components
                this.scene = null;
                this.wireframeScene = null;
                this.camera = null;
                this.renderer = null;
                this.textMesh = null;
                this.wireframeTextMesh = null;
                
                // Simplified render targets
                this.mainRenderTarget = null;
                this.wireframeRenderTarget = null;
                this.compositeQuad = null;
                
                // Professional interaction system
                this.mouse = new THREE.Vector2();
                this.targetRotation = new THREE.Euler();
                this.currentRotation = new THREE.Euler();
                this.rotationDamping = 0.12;
                this.maxRotationX = Math.PI / 3;
                this.maxRotationY = Math.PI / 2.5;
                
                // Scroll zoom system
                this.baseScale = 1.0;
                this.currentScale = 1.0;
                this.targetScale = 1.0;
                this.scaleDamping = 0.15;
                this.minScale = 0.8;
                this.maxScale = 2.5;
                this.zoomThreshold = 1.6; // When to show overlay
                
                // UI elements
                this.overlay = document.getElementById('overlay');
                this.timedHint = document.getElementById('timed-hint');
                this.info = document.getElementById('info');
                this.fpsElement = document.getElementById('fps');
                this.overlayVisible = false;
                
                // Simple tutorial state
                this.hasSeenMotto = false;
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                this.init();
            }
            
            init() {
                console.log('üöÄ Starting Scroll-Zoom Professional Renderer');
                try {
                    this.setupRenderer();
                    this.setupScenes();
                    this.setupCamera();
                    this.setupProfessionalLighting();
                    this.setupRenderTargets();
                    this.loadFont();
                    this.setupEventListeners();
                    this.startSimpleTutorial();
                    this.animate();
                    console.log('‚úÖ All systems initialized successfully');
                } catch (error) {
                    console.error('‚ùå Initialization failed:', error);
                    this.showErrorMessage(error);
                }
            }
            
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance",
                    stencilBuffer: false
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x1a1a2e, 1.0);
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.body.appendChild(this.renderer.domElement);
                console.log('‚úÖ High-performance renderer ready');
            }
            
            setupScenes() {
                this.scene = new THREE.Scene();
                this.wireframeScene = new THREE.Scene();
                this.wireframeScene.background = new THREE.Color(0x000000);
                console.log('‚úÖ Scenes created');
            }
            
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    65, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 0, 6);
                console.log('‚úÖ Camera positioned');
            }
            
            setupProfessionalLighting() {
                // Ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.25);
                this.scene.add(ambientLight);
                
                // Professional concentrated spot light from bottom-right
                const spotLight = new THREE.SpotLight(0xffffff, 3.0);
                spotLight.position.set(10, -8, 12);
                spotLight.target.position.set(0, 0, 0);
                spotLight.angle = Math.PI / 7;
                spotLight.penumbra = 0.4;
                spotLight.decay = 1.8;
                spotLight.distance = 40;
                this.scene.add(spotLight);
                this.scene.add(spotLight.target);
                
                // Colorful metallic rim lights
                const blueRimLight = new THREE.DirectionalLight(0x4488ff, 1.2);
                blueRimLight.position.set(-6, 3, 8);
                this.scene.add(blueRimLight);
                
                const goldRimLight = new THREE.DirectionalLight(0xffaa44, 0.8);
                goldRimLight.position.set(8, 6, -4);
                this.scene.add(goldRimLight);
                
                // Subtle fill light
                const fillLight = new THREE.DirectionalLight(0x6677aa, 0.3);
                fillLight.position.set(-4, 10, 6);
                this.scene.add(fillLight);
                
                console.log('‚úÖ Professional metallic lighting complete');
            }
            
            setupRenderTargets() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.mainRenderTarget = new THREE.WebGLRenderTarget(width, height, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                });
                
                this.wireframeRenderTarget = new THREE.WebGLRenderTarget(width, height, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                });
                
                this.createCompositeShader();
                console.log('‚úÖ Simplified render targets ready');
            }
            
            createCompositeShader() {
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                const uniforms = {
                    uMainTexture: { value: this.mainRenderTarget.texture },
                    uWireframeTexture: { value: this.wireframeRenderTarget.texture },
                    uMouse: { value: new THREE.Vector2() },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uLensRadius: { value: 0.13 },
                    uTime: { value: 0 }
                };
                
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D uMainTexture;
                    uniform sampler2D uWireframeTexture;
                    uniform vec2 uMouse;
                    uniform vec2 uResolution;
                    uniform float uLensRadius;
                    uniform float uTime;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 uv = vUv;
                        vec2 mouseUV = uMouse * 0.5 + 0.5;
                        
                        // Perfect circular lens
                        float aspectRatio = uResolution.x / uResolution.y;
                        vec2 correctedUV = (uv - mouseUV) * vec2(aspectRatio, 1.0);
                        float distance = length(correctedUV);
                        
                        vec4 mainColor = texture2D(uMainTexture, uv);
                        vec4 wireframeColor = texture2D(uWireframeTexture, uv);
                        
                        // Inside lens effect
                        if (distance < uLensRadius) {
                            // Professional pink gradient
                            float normalizedDist = distance / uLensRadius;
                            vec3 edgePink = vec3(0.94, 0.48, 0.78);
                            vec3 centerPink = vec3(0.97, 0.85, 0.93);
                            vec3 pinkGradient = mix(centerPink, edgePink, normalizedDist * 0.65);
                            
                            // Detect wireframe lines
                            float wireframeBrightness = dot(wireframeColor.rgb, vec3(0.299, 0.587, 0.114));
                            
                            if (wireframeBrightness > 0.3) {
                                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                            } else {
                                gl_FragColor = vec4(pinkGradient, 1.0);
                            }
                        } else {
                            gl_FragColor = mainColor;
                        }
                        
                        // Professional lens edge glow
                        float edgeGlow = smoothstep(uLensRadius + 0.015, uLensRadius - 0.004, distance);
                        vec3 pinkGlow = vec3(0.9, 0.5, 0.8) * 0.35;
                        gl_FragColor.rgb += pinkGlow * edgeGlow * (1.0 - step(distance, uLensRadius));
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms,
                    vertexShader,
                    fragmentShader
                });
                
                this.compositeQuad = new THREE.Mesh(geometry, material);
                this.lensUniforms = uniforms;
            }
            
            loadFont() {
                const fontLoader = new THREE.FontLoader();
                
                fontLoader.load(
                    'https://threejs.org/examples/fonts/gentilis_bold.typeface.json',
                    (font) => {
                        console.log('‚úÖ Font loaded');
                        this.createTextGeometry(font);
                    },
                    (progress) => {
                        console.log('üì• Font loading:', Math.round(progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('‚ùå Font error:', error);
                        this.createFallbackText();
                    }
                );
            }
            
            createTextGeometry(font) {
                // Professional 3D text
                const textGeometry = new THREE.TextGeometry('Evanolott', {
                    font: font,
                    size: 1.0,
                    height: 0.2,
                    curveSegments: 14,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.015,
                    bevelSegments: 10
                });
                
                // Center the text
                textGeometry.computeBoundingBox();
                const centerX = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                const centerY = -0.5 * (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y);
                textGeometry.translate(centerX, centerY, 0);
                
                // Professional metallic material
                const metallicMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0,
                    metalness: 0.95,
                    roughness: 0.05
                });
                
                // Wireframe material
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                });
                
                // Create both meshes
                this.textMesh = new THREE.Mesh(textGeometry, metallicMaterial);
                this.scene.add(this.textMesh);
                
                this.wireframeTextMesh = new THREE.Mesh(textGeometry.clone(), wireframeMaterial);
                this.wireframeScene.add(this.wireframeTextMesh);
                
                console.log('‚úÖ Professional 3D text created');
            }
            
            createFallbackText() {
                const geometry = new THREE.BoxGeometry(3.5, 0.8, 0.4);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                this.textMesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.textMesh);
                
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                });
                this.wireframeTextMesh = new THREE.Mesh(geometry.clone(), wireframeMaterial);
                this.wireframeScene.add(this.wireframeTextMesh);
                
                console.log('‚ö†Ô∏è Using fallback geometry');
            }
            
            setupEventListeners() {
                window.addEventListener('resize', this.onWindowResize.bind(this));
                window.addEventListener('mousemove', this.onMouseMove.bind(this));
                
                // Scroll event for zooming
                window.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
                
                // Touch events for mobile
                window.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: true });
                window.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });
            }
            
            startSimpleTutorial() {
                // Show hint after 5 seconds only if they haven't seen the motto
                setTimeout(() => {
                    if (!this.hasSeenMotto && this.timedHint) {
                        this.timedHint.classList.add('show');
                        console.log('üí° Tutorial hint shown');
                    }
                }, 5000);
            }
            
            onWheel(event) {
                event.preventDefault();
                
                // Zoom logic
                const zoomSpeed = 0.002;
                const deltaY = event.deltaY;
                
                // Scroll up (negative delta) = zoom in
                this.targetScale += -deltaY * zoomSpeed;
                this.targetScale = Math.max(this.minScale, Math.min(this.maxScale, this.targetScale));
            }
            
            onTouchStart(event) {
                if (event.touches.length === 2) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    this.initialPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                }
            }
            
            onTouchMove(event) {
                if (event.touches.length === 2 && this.initialPinchDistance) {
                    event.preventDefault();
                    
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    const scale = currentDistance / this.initialPinchDistance;
                    this.targetScale = Math.max(this.minScale, Math.min(this.maxScale, this.targetScale * scale));
                    this.initialPinchDistance = currentDistance;
                }
            }
            
            onMouseMove(event) {
                // Update mouse for lens
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (this.lensUniforms) {
                    this.lensUniforms.uMouse.value.copy(this.mouse);
                }
                
                // Professional rotation mapping
                this.targetRotation.y = this.mouse.x * this.maxRotationY;
                this.targetRotation.x = this.mouse.y * this.maxRotationX * 0.6;
            }
            
            updateOverlay() {
                const shouldShowOverlay = this.currentScale >= this.zoomThreshold;
                
                if (shouldShowOverlay && !this.overlayVisible) {
                    // Show overlay and mark that user has seen the motto
                    this.overlay.classList.add('active');
                    this.info.style.opacity = '0.3';
                    this.fpsElement.style.opacity = '0.3';
                    this.overlayVisible = true;
                    this.hasSeenMotto = true;
                    
                    // Hide tutorial hint permanently once motto is seen
                    if (this.timedHint) {
                        this.timedHint.classList.remove('show');
                    }
                    
                    console.log('‚ú® Overlay revealed - tutorial disabled');
                } else if (!shouldShowOverlay && this.overlayVisible) {
                    // Hide overlay
                    this.overlay.classList.remove('active');
                    this.info.style.opacity = '0.8';
                    this.fpsElement.style.opacity = '0.7';
                    this.overlayVisible = false;
                    console.log('üîÑ Overlay hidden');
                }
            }
            
            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
                
                // Resize render targets
                this.mainRenderTarget.setSize(width, height);
                this.wireframeRenderTarget.setSize(width, height);
                
                if (this.lensUniforms) {
                    this.lensUniforms.uResolution.value.set(width, height);
                }
                
                console.log('‚úÖ Resized to', width, 'x', height);
            }
            
            updatePerformance() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.fpsElement.textContent = `FPS: ${fps} | Calls: ${this.renderer.info.render.calls}`;
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                    this.renderer.info.reset();
                }
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                const currentTime = performance.now() * 0.001;
                if (this.lensUniforms) {
                    this.lensUniforms.uTime.value = currentTime;
                }
                
                // Update scale with smooth interpolation
                this.currentScale += (this.targetScale - this.currentScale) * this.scaleDamping;
                
                // Professional smooth rotation and scaling
                if (this.textMesh && this.wireframeTextMesh) {
                    // Smooth interpolation
                    this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * this.rotationDamping;
                    this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * this.rotationDamping;
                    
                    // Apply transformations to both meshes
                    this.textMesh.rotation.x = this.currentRotation.x;
                    this.textMesh.rotation.y = this.currentRotation.y;
                    this.textMesh.rotation.z = 0;
                    this.textMesh.scale.setScalar(this.currentScale);
                    
                    this.wireframeTextMesh.rotation.copy(this.textMesh.rotation);
                    this.wireframeTextMesh.scale.copy(this.textMesh.scale);
                }
                
                // Update overlay visibility
                this.updateOverlay();
                
                this.render();
                this.updatePerformance();
            }
            
            render() {
                // Multi-pass rendering
                
                // Pass 1: Render main metallic scene
                this.renderer.setRenderTarget(this.mainRenderTarget);
                this.renderer.render(this.scene, this.camera);
                
                // Pass 2: Render wireframe scene
                this.renderer.setRenderTarget(this.wireframeRenderTarget);
                this.renderer.render(this.wireframeScene, this.camera);
                
                // Pass 3: Composite with lens effect
                this.renderer.setRenderTarget(null);
                
                const compositeScene = new THREE.Scene();
                const compositeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                compositeScene.add(this.compositeQuad);
                
                this.renderer.render(compositeScene, compositeCamera);
            }
            
            showErrorMessage(error) {
                document.body.innerHTML = `
                    <div style="color: white; text-align: center; padding: 50px; font-family: Arial; background: #1a1a2e;">
                        <h2>‚ö†Ô∏è WebGL Error</h2>
                        <p>Failed to initialize the 3D renderer.</p>
                        <p style="color: #ff6b6b;">Error: ${error.message}</p>
                        <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 20px; background: #4a9eff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            üîÑ Reload Page
                        </button>
                    </div>
                `;
            }
        }
        
        // Initialize with comprehensive error handling
        window.addEventListener('DOMContentLoaded', () => {
            console.log('üéØ Starting Scroll-Zoom Professional 3D Text Renderer');
            try {
                new ScrollZoom3DTextRenderer();
            } catch (error) {
                console.error('‚ùå Critical initialization error:', error);
            }
        });
        
        // Global error handler
        window.addEventListener('error', (e) => {
            if (e.message !== 'Script error.') {
                console.error('‚ùå Runtime error:', e.message, e.filename, e.lineno);
            }
        });
    </script>
</body>
</html>